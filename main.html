<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BDI Blocks World</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8fafc;
      color: #111827;
    }

    .sidebar {
      position: fixed;
      left: 0; top: 0; bottom: 0;
      width: 220px;
      background: #4FD1C5; /* updated */
      color: white;
      padding: 25px 20px;
    }

    .sidebar h2 {
      font-size: 20px;
      margin-bottom: 20px;
    }

    .sidebar nav p {
      margin: 12px 0;
      cursor: pointer;
    }

    .main {
      margin-left: 220px;
      padding: 20px;
    }

    .header {
      background: #4FD1C5; /* updated */
      padding: 20px 30px;
      border-radius: 12px;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 25px;
    }

    .user-info {
      display: flex;
      align-items: center;
    }

    .user-info img {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      margin-right: 10px;
    }

    .canvas-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      margin-bottom: 30px;
    }

    canvas {
      display: block;
      margin: auto;
      border: 2px solid #e5e7eb;
      background: #fff;
    }

    .panels {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
    }

    .panel {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.04);
    }

    .panel h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #0f172a;
    }

    .button {
      padding: 10px;
      border: none;
      border-radius: 6px;
      color: white;
      width: 100%;
      margin-bottom: 10px;
      font-weight: bold;
      cursor: pointer;
    }

    .btn-send { background: #4FD1C5; }  /* updated */
    .btn-add { background: #38B2AC; }   /* darker shade */
    .btn-reset { background: #319795; } /* even darker */
    
    input[type="text"] {
      width: 100%;
      padding: 10px;
      margin-bottom: 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
    }

    .log {
      font-size: 13px;
      max-height: 150px;
      overflow-y: auto;
      background: #f1f5f9;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    .status {
      font-size: 14px;
    }
  </style>
</head>
<body>

  <div class="sidebar">
    <h2>BDI Blocks World</h2>
    <nav>
      <p>Simulation</p>
      <p>History</p>
      <hr style="border-color: #ffffff44;">
      <p>Profile</p>
      <p>Sign In</p>
      <p>Sign Up</p>
    </nav>
  </div>

  <div class="main">
    <div class="header">
      <div>Simulation</div>
      <div class="user-info">
        <img src="https://i.pravatar.cc/100" alt="User"/>
        <span>Lord Farquad</span>
      </div>
    </div>

    <div class="canvas-card">
      <canvas id="simCanvas" width="600" height="350"></canvas>
    </div>

    <div class="panels">
      <div class="panel">
        <h3>Control Panel</h3>
        <input id="goalInput" type="text" placeholder="e.g. A on B">
        <button class="button btn-send" onclick="sendGoal()">Send Goal</button>
        <button class="button btn-add" onclick="addBlock()">Add Block</button>
        <button class="button btn-reset" onclick="resetBlocks()">Reset</button>
      </div>

      <div class="panel">
        <h3>Status</h3>
        <div class="status" id="status">Waiting for goal...</div>
      </div>

      <div class="panel">
        <h3>Log</h3>
        <div class="log" id="logBox"></div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("simCanvas");
    const ctx = canvas.getContext("2d");
    const blockSize = 50;
    let positions = {};
    let nextX = 80;

    let beliefs = {
      blocks: {
        A: { on: 'table' },
        B: { on: 'table' },
        C: { on: 'table' }
      },
      holding: null
    };

    // Initialize positions for default blocks
    positions['A'] = 80;
    positions['B'] = 180;
    positions['C'] = 280;
    nextX = 380;

    let armX = 100, armY = 0, holdingBlock = null;
    let armTargetX = null, armTargetY = null;
    let actionQueue = [];
    let currentAction = null;
    let ws = null;
    let connectionAttempts = 0;
    const maxRetries = 3;

    function connectWebSocket() {
      try {
        ws = new WebSocket("ws://localhost:8080");
        
        ws.onopen = () => {
          connectionAttempts = 0;
          document.getElementById("status").innerHTML = "ðŸŸ¢ Connected to server";
          log("âœ… Connected to BDI agent");
        };

        ws.onmessage = (event) => {
          const msg = JSON.parse(event.data);
          if (msg.type === "plan") {
            log(`ðŸ“¦ Plan received: ${JSON.stringify(msg.plan)}`);
            actionQueue = msg.plan.map(([type, ...args]) => ({ type, args }));
            runNextAction();
          } else if (msg.type === "state") {
            // Update frontend state with server state
            beliefs = msg.beliefs;
            updatePositions();
            log("ðŸ”„ State synchronized with server");
          } else if (msg.type === "error") {
            log(`âŒ Server error: ${msg.message}`);
            document.getElementById("status").innerHTML = `âŒ Error: ${msg.message}`;
          }
        };

        ws.onerror = (error) => {
          log("âŒ Connection error");
          document.getElementById("status").innerHTML = "ðŸ”´ Connection error";
        };

        ws.onclose = () => {
          log("ðŸ”Œ Disconnected from server");
          document.getElementById("status").innerHTML = "ðŸ”´ Disconnected";
          
          if (connectionAttempts < maxRetries) {
            connectionAttempts++;
            log(`ðŸ”„ Retrying connection (${connectionAttempts}/${maxRetries})...`);
            setTimeout(connectWebSocket, 2000);
          } else {
            log("âŒ Failed to connect after multiple attempts");
            document.getElementById("status").innerHTML = "âŒ Connection failed - is server running?";
          }
        };
      } catch (error) {
        log("âŒ Failed to create WebSocket connection");
        document.getElementById("status").innerHTML = "âŒ Cannot connect to server";
      }
    }

    function log(text) {
      const logBox = document.getElementById("logBox");
      logBox.innerHTML += text + "<br>";
      logBox.scrollTop = logBox.scrollHeight;
    }

    function sendGoal() {
      const goalText = document.getElementById("goalInput").value.trim();
      
      // Enhanced validation
      if (!goalText) {
        alert("Please enter a goal");
        return;
      }
      
      if (!goalText.includes(" on ")) {
        alert("Goal must be in format: 'block1 on block2' (e.g., 'A on B')");
        return;
      }
      
      const parts = goalText.split(" on ");
      if (parts.length !== 2) {
        alert("Goal must have exactly one 'on' keyword (e.g., 'A on B')");
        return;
      }
      
      const [block1, block2] = parts.map(p => p.trim());
      
      // Validate block names
      if (!/^[A-Z]$/.test(block1) || !/^[A-Z]$/.test(block2)) {
        alert("Block names must be single uppercase letters (A-Z)");
        return;
      }
      
      if (block1 === block2) {
        alert("Cannot place a block on itself");
        return;
      }
      
      // Check if blocks exist
      if (!beliefs.blocks[block1]) {
        alert(`Block ${block1} does not exist. Add it first.`);
        return;
      }
      
      if (block2 !== "table" && !beliefs.blocks[block2]) {
        alert(`Block ${block2} does not exist. Add it first or use 'table'.`);
        return;
      }
      
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        alert("Not connected to server. Please wait for connection...");
        return;
      }
      
      ws.send(JSON.stringify({ type: "goal", goal: goalText }));
      document.getElementById("status").textContent = `ðŸŽ¯ Goal sent: ${goalText}`;
      log(`ðŸŽ¯ Goal sent: ${goalText}`);
    }

    function runNextAction() {
      if (actionQueue.length === 0) {
        document.getElementById("status").innerHTML = "âœ… <span style='color:#4FD1C5;'>Goal complete.</span>";
        return;
      }

      currentAction = actionQueue.shift();
      const { type, args } = currentAction;

      if (type === "pickup") {
        const block = args[0];
        armTargetX = positions[block] + 25;
        armTargetY = 300 - blockSize * getBlockLevel(block);
        holdingBlock = block;
      } else if (type === "putdown") {
        const dest = args[1];
        armTargetX = positions[dest] + 25;
        armTargetY = 300 - blockSize * getNextStackLevel(dest);
      }
    }

    function updateArmPosition() {
      if (!currentAction) return;

      const speed = 4;
      if (Math.abs(armX - armTargetX) > speed) {
        armX += armX < armTargetX ? speed : -speed;
      }
      if (Math.abs(armY - armTargetY) > speed) {
        armY += armY < armTargetY ? speed : -speed;
      }

      if (Math.abs(armX - armTargetX) <= speed && Math.abs(armY - armTargetY) <= speed) {
        const { type, args } = currentAction;

        if (type === "putdown") {
          const [block, base] = args;
          beliefs.blocks[block] = base;
          holdingBlock = null;
        } else if (type === "pickup") {
          const [block] = args;
          beliefs.blocks[block] = null;
        }

        currentAction = null;
        setTimeout(runNextAction, 300);
      }
    }

    function getBlockLevel(block) {
      let level = 0;
      let under = beliefs.blocks[block];
      while (under && under !== "table") {
        level++;
        under = beliefs.blocks[under];
      }
      return level;
    }

    function getNextStackLevel(base) {
      let level = 1;
      let onTop = Object.keys(beliefs.blocks).find(k => beliefs.blocks[k] === base);
      while (onTop) {
        level++;
        onTop = Object.keys(beliefs.blocks).find(k => beliefs.blocks[k] === onTop);
      }
      return level;
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.moveTo(0, 300);
      ctx.lineTo(canvas.width, 300);
      ctx.strokeStyle = "#999";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(armX, 0);
      ctx.lineTo(armX, armY);
      ctx.strokeStyle = "black";
      ctx.lineWidth = 4;
      ctx.stroke();

      const drawn = {};
      function getStack(block) {
        const stack = [];
        let current = block;
        while (current && beliefs.blocks[current] !== "table") {
          stack.push(current);
          current = beliefs.blocks[current];
        }
        stack.push(current);
        return stack.reverse();
      }

      Object.keys(positions).forEach(block => {
        if (drawn[block] || block === holdingBlock) return;

        const stack = getStack(block);
        const baseX = positions[stack[0]];

        stack.forEach((b, i) => {
          const x = baseX;
          const y = 300 - blockSize * (stack.length - i);
          drawn[b] = true;

          ctx.fillStyle = "#4FD1C5"; // updated block color
          ctx.fillRect(x, y, blockSize, blockSize);
          ctx.fillStyle = "white";
          ctx.fillText(b, x + 20, y + 30);
        });
      });

      if (holdingBlock) {
        ctx.fillStyle = "orange";
        ctx.fillRect(armX - 25, armY, blockSize, blockSize);
        ctx.fillStyle = "black";
        ctx.fillText(holdingBlock, armX - 5, armY + 30);
      }
    }

    function animate() {
      updateArmPosition();
      draw();
      requestAnimationFrame(animate);
    }

    function resetBlocks() {
      beliefs = { blocks: {}, holding: null };
      positions = {};
      nextX = 80;
      armX = 100; armY = 0;
      holdingBlock = null;
      actionQueue = [];
      currentAction = null;
      
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "reset" }));
        log("ðŸ”„ Reset command sent to server");
      } else {
        log("ï¿½ Local environment reset (server not connected)");
      }
      
      document.getElementById("status").textContent = "ðŸ”„ Reset complete.";
    }

    function addBlock() {
      const name = prompt("Enter block name (single uppercase letter):");
      if (!name || !/^[A-Z]$/.test(name)) {
        alert("Invalid block name. Use a single uppercase letter (A-Z).");
        return;
      }
      if (positions[name]) {
        alert("Block already exists.");
        return;
      }

      beliefs.blocks[name] = "table";
      positions[name] = nextX;
      nextX += 100;
      log(`âž• Added block: ${name}`);
    }

    function updatePositions() {
      // Update positions based on current beliefs
      Object.keys(beliefs.blocks).forEach(block => {
        if (!positions[block]) {
          positions[block] = nextX;
          nextX += 100;
        }
      });
    }

    // Initialize connection and start animation
    connectWebSocket();
    animate();
  </script>
</body>
</html>
