<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>BDI Blocks World</title>
  <style>
    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background-color: #f8fafc;
      color: #111827;
    }

    .sidebar {
      position: fixed;
      left: 0; top: 0; bottom: 0;
      width: 220px;
      background: #4FD1C5;
      color: white;
      padding: 25px 20px;
    }

    .sidebar h2 {
      font-size: 20px;
      margin-bottom: 20px;
    }

    .sidebar nav p {
      margin: 12px 0;
      cursor: pointer;
    }

    .main {
      margin-left: 220px;
      padding: 20px;
    }

    .header {
      background: #4FD1C5;
      padding: 20px 30px;
      border-radius: 12px;
      color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 25px;
    }

    .user-info {
      display: flex;
      align-items: center;
    }

    .user-info img {
      width: 35px;
      height: 35px;
      border-radius: 50%;
      margin-right: 10px;
    }

    .canvas-card {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
      margin-bottom: 30px;
    }

    canvas {
      display: block;
      margin: auto;
      border: 2px solid #e5e7eb;
      background: #fff;
    }

    .panels {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 20px;
    }

    .panel {
      background: white;
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.04);
    }

    .panel h3 {
      margin-top: 0;
      margin-bottom: 15px;
      color: #0f172a;
    }

    .button {
      padding: 10px;
      border: none;
      border-radius: 6px;
      color: white;
      width: 100%;
      margin-bottom: 10px;
      font-weight: bold;
      cursor: pointer;
    }

    .btn-send { background: #4FD1C5; }
    .btn-add { background: #38B2AC; }
    .btn-reset { background: #319795; }

    input[type="text"] {
      width: 100%;
      padding: 10px;
      margin-bottom: 12px;
      border: 1px solid #d1d5db;
      border-radius: 6px;
    }

    .log {
      font-size: 13px;
      max-height: 150px;
      overflow-y: auto;
      background: #f1f5f9;
      padding: 10px;
      border-radius: 6px;
      border: 1px solid #e2e8f0;
    }

    .status {
      font-size: 14px;
    }
  </style>
</head>
<body>

  <div class="sidebar">
    <h2>BDI Blocks World</h2>
    <nav>
      <p>Simulation</p>
      <p>History</p>
      <hr style="border-color: #ffffff44;">
      <p>Profile</p>
      <p>Sign In</p>
      <p>Sign Up</p>
    </nav>
  </div>

  <div class="main">
    <div class="header">
      <div>Simulation</div>
      <div class="user-info">
        <img src="https://i.pravatar.cc/100" alt="User"/>
        <span>Lord Farquad</span>
      </div>
    </div>

    <div class="canvas-card">
      <canvas id="simCanvas" width="900" height="350"></canvas>

    </div>

    <div class="panels">
      <div class="panel">
        <h3>Control Panel</h3>
        <input id="goalInput" type="text" placeholder="e.g. A on B">
        <button class="button btn-send" onclick="sendGoal()">Send Goal</button>
        <button class="button btn-add" onclick="addBlock()">Add Block</button>
        <button class="button btn-reset" onclick="resetBlocks()">Reset</button>
		<button class="button btn-reset" onclick="undoAddBlock()">Undo Add</button>
      </div>

      <div class="panel">
        <h3>Status</h3>
        <div class="status" id="status">Waiting for goal...</div>
      </div>

      <div class="panel">
        <h3>Log</h3>
        <div class="log" id="logBox"></div>
      </div>
    </div>
  </div>

  <script>
	  // This is the canvas and arm setup 
  const canvas = document.getElementById("simCanvas");
  const ctx = canvas.getContext("2d");
  const blockSize = 50;

	  // Below it stores the X positions of the blocks
  let positions = {};
  let nextX = 80;
  let currentBlockCharCode = "A".charCodeAt(0);

	  // This is the wolrd state and arm control 
  let beliefs = {
    blocks: {},
    holding: null
  };
  let armX = 100, armY = 0, holdingBlock = null;
  let armTargetX = null, armTargetY = null;
  let actionQueue = [];
  let currentAction = null;
  let moveStage = "lift";
  let returningHome = false;

	  // Websocket connection 

  const ws = new WebSocket(`ws://${window.location.host}/ws`);

  ws.onopen = () => {
    log("âœ… Client connected to BDI WebSocket server.");
  };

  ws.onerror = (error) => {
    log("âŒ WebSocket error: Could not connect to server.");
    console.error("WebSocket Error:", error);
  };

	  // Below it receives  a plan from the server and it starts executing 

  ws.onmessage = (event) => {
    const msg = JSON.parse(event.data);
    if (msg.type === "plan") {
      log(`ðŸ“¦ Plan received: ${JSON.stringify(msg.plan)}`);
      actionQueue = msg.plan.map(([type, ...args]) => ({ type, args }));
      runNextAction();
    }
  };

	  // Below it logs messsages to the log box panel 

  function log(text) {
    const logBox = document.getElementById("logBox");
    logBox.innerHTML += text + "<br>";
    logBox.scrollTop = logBox.scrollHeight;
  }

	  // Below fucntion is to send goal such as A on B to the server

  function sendGoal() {
    const goalText = document.getElementById("goalInput").value.trim();
    if (!goalText.includes(" on ")) {
      alert("Goal must be in format: A on B");
      return;
    }
    ws.send(JSON.stringify({ type: "goal", goal: goalText }));
    document.getElementById("status").textContent = `ðŸŽ¯ Goal sent: ${goalText}`;
  }

	  // Below code handles picking up and putting down blocks step by step

  function runNextAction() {
    if (actionQueue.length === 0) {
      document.getElementById("status").innerHTML = "âœ… <span style='color:#4FD1C5;'>Goal complete.</span>";
      return;
    }

    currentAction = actionQueue.shift();
    const { type, args } = currentAction;
    moveStage = "lift";

    if (type === "pickup") {
      const block = args[0];
      armTargetX = positions[block] + blockSize / 2;
      armTargetY = 300 - blockSize * getBlockLevel(block);
      holdingBlock = null;
    } else if (type === "putdown") {
      const [block, dest] = args;
      armTargetX = positions[dest] + blockSize / 2;
      armTargetY = 300 - blockSize * (getNextStackLevel(dest) + 1);
    }
  }

	  // Below function is used to move the arm 

  function updateArmPosition() {
    const speed = 4;
    const safeHeight = 20;
    const homeX = 100, homeY = 0;

    if (returningHome) {
      let arrived = true;

      if (Math.abs(armX - homeX) > speed) {
        armX += armX < homeX ? speed : -speed;
        arrived = false;
      } else {
        armX = homeX;
      }

      if (Math.abs(armY - homeY) > speed) {
        armY += armY < homeY ? speed : -speed;
        arrived = false;
      } else {
        armY = homeY;
      }

      if (arrived) {
        returningHome = false;
        runNextAction();
      }

      return;
    }

    if (!currentAction) return;

    const { type, args } = currentAction;

    if (type === "pickup") {
      const block = args[0];
      armTargetX = positions[block] + blockSize / 2;
      armTargetY = 300 - blockSize * getBlockLevel(block);
    } else if (type === "putdown") {
      const [block, dest] = args;
      armTargetX = positions[dest] + blockSize / 2;
      armTargetY = 300 - blockSize * (getNextStackLevel(dest) + 1);
    }

    if (moveStage === "lift") {
      if (armY > safeHeight) {
        armY -= speed;
      } else {
        moveStage = "horizontal";
      }
    } else if (moveStage === "horizontal") {
      if (Math.abs(armX - armTargetX) > speed) {
        armX += armX < armTargetX ? speed : -speed;
      } else {
        armX = armTargetX;
        moveStage = "lower";
      }
    } else if (moveStage === "lower") {
      if (Math.abs(armY - armTargetY) > speed) {
        armY += armY < armTargetY ? speed : -speed;
      } else {
        armY = armTargetY;

        if (type === "pickup") {
          const [block] = args;
          if (!holdingBlock) {
            holdingBlock = block;
            beliefs.blocks[block] = null;
          }
        } else if (type === "putdown") {
          const [block, base] = args;
          beliefs.blocks[block] = base;
          positions[block] = positions[base];
          holdingBlock = null;
        }

        currentAction = null;
        returningHome = true; 
      }
    }
  }

	  // Thi sfunction calculates how many blocks are below a given block 

  function getBlockLevel(block) {
    let level = 0;
    let under = beliefs.blocks[block];
    while (under && under !== "table") {
      level++;
      under = beliefs.blocks[under];
    }
    return level;
  }

	  // Calcualktes how tall a stack is for a block 

  function getNextStackLevel(base) {
    let level = 0;
    let onTop = Object.keys(beliefs.blocks).find(k => beliefs.blocks[k] === base);
    while (onTop) {
      level++;
      onTop = Object.keys(beliefs.blocks).find(k => beliefs.blocks[k] === onTop);
    }
    return level;
  }

	  // The drawarm function is to draw the robot arm

  function drawArm(ctx, x, y) {
    const gripperWidth = blockSize + 10;
    const prongLength = 20;
    const gripperThickness = 4;

    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, y);
    ctx.lineWidth = gripperThickness;
    ctx.strokeStyle = "black";
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x - gripperWidth / 2, y);
    ctx.lineTo(x + gripperWidth / 2, y);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x - gripperWidth / 2, y);
    ctx.lineTo(x - gripperWidth / 2, y + prongLength);
    ctx.stroke();

    ctx.beginPath();
    ctx.moveTo(x + gripperWidth / 2, y);
    ctx.lineTo(x + gripperWidth / 2, y + prongLength);
    ctx.stroke();
  }
	  // This draw function draws the table=, arm , blocks, and the blocks thats being held

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.beginPath();
    ctx.moveTo(0, 300);
    ctx.lineTo(canvas.width, 300);
    ctx.strokeStyle = "#999";
    ctx.lineWidth = 2;
    ctx.stroke();

    drawArm(ctx, armX, armY);

    const drawn = new Set();
    const allBlocks = Object.keys(positions);
    const supportedBlocks = Object.values(beliefs.blocks);
    const topBlocks = allBlocks.filter(b => !supportedBlocks.includes(b));

    for (const top of topBlocks) {
      if (top === holdingBlock || drawn.has(top)) continue;

      const stack = [];
      let current = top;

      while (current && beliefs.blocks[current] && beliefs.blocks[current] !== 'table') {
        stack.push(current);
        drawn.add(current);
        current = beliefs.blocks[current];
      }

      if (current && !drawn.has(current)) {
        stack.push(current);
        drawn.add(current);
      }

      stack.reverse().forEach((b, i) => {
        const x = positions[b];
        const y = 300 - blockSize * (i + 1);
        ctx.fillStyle = "#4FD1C5";
        ctx.fillRect(x, y, blockSize, blockSize);
        ctx.fillStyle = "white";
        ctx.fillText(b, x + 20, y + 30);
      });
    }

    if (holdingBlock) {
      ctx.fillStyle = "orange";
      ctx.fillRect(armX - 25, armY, blockSize, blockSize);
      ctx.fillStyle = "black";
      ctx.fillText(holdingBlock, armX - 5, armY + 30);
    }
  }

	  // This functon is to keep the animation going 

  function animate() {
    updateArmPosition();
    draw();
    requestAnimationFrame(animate);
  }

	  // resets everything to initial state 

  function resetBlocks() {
    beliefs = { blocks: {}, holding: null };
    positions = {};
    nextX = 80;
    currentBlockCharCode = "A".charCodeAt(0);
    armX = 100;
    armY = 0;
    holdingBlock = null;
    actionQueue = [];
    currentAction = null;
    moveStage = "lift";
    returningHome = false;
    document.getElementById("status").textContent = "ðŸ”„ Reset complete.";
    log("ðŸ” Environment reset.");
  }

	  // Adds bew blocks to the table up to Z

  function addBlock() {
    if (currentBlockCharCode > "Z".charCodeAt(0)) {
      alert("All alphabet blocks (Aâ€“Z) have been added.");
      return;
    }

    const name = String.fromCharCode(currentBlockCharCode);
    if (positions[name]) {
      alert(`Block ${name} already exists.`);
      return;
    }

    beliefs.blocks[name] = "table";
    positions[name] = nextX;
    nextX += 100;
    currentBlockCharCode++;

    log(`âž• Added block: ${name}`);

    ws.send(JSON.stringify({
      type: "update",
      beliefs: {
        blocks: { [name]: "table" }
      }
    }));
  }

	  // Removes the last added block 

  function undoAddBlock() {
    if (currentBlockCharCode <= "A".charCodeAt(0)) {
      alert("No blocks to undo.");
      return;
    }

    currentBlockCharCode--;
    const name = String.fromCharCode(currentBlockCharCode);

    if (!positions[name]) {
      alert(`Block ${name} does not exist.`);
      return;
    }

    delete beliefs.blocks[name];
    delete positions[name];
    nextX -= 100;

    log(`â†©ï¸ Undid block: ${name}`);

    ws.send(JSON.stringify({
      type: "update",
      beliefs: {
        blocks: { [name]: null }
      }
    }));

    animate();
  }
	  // Starts the animation loop

  animate();
</script>



</body>
</html>
